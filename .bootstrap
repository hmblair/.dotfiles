#!/usr/bin/env bash
# Bootstrap script for fresh machines
# Usage: git clone <repo> ~/.dotfiles && ~/.dotfiles/.bootstrap [--global] [--force] [--uninstall]

set -e

# Parse arguments
GLOBAL_INSTALL=0
FORCE_INSTALL=0
UNINSTALL=0
for arg in "$@"; do
  case "$arg" in
    --global) GLOBAL_INSTALL=1 ;;
    --force|-f) FORCE_INSTALL=1 ;;
    --uninstall) UNINSTALL=1 ;;
  esac
done

# Resolve symlinks to get the actual script location (POSIX-compatible)
DOTFILES_DIR="$(cd "$(dirname "$0")" && pwd -P)"
LOCAL_PREFIX="$HOME/.local"
GLOBAL_PREFIX="/usr/local"
LOG_DIR="$LOCAL_PREFIX/log/install"

# Colors
_GREEN='\033[0;32m'
_RED='\033[0;31m'
_CYAN='\033[0;36m'
_NC='\033[0m'

info() { printf "${_CYAN}==> %s${_NC}\n" "$1"; }
success() { printf "${_GREEN}==> %s${_NC}\n" "$1"; }
error() { printf "${_RED}==> %s${_NC}\n" "$1" >&2; }
detail() { printf "    %s\n" "$1"; }

# Programs installed by bootstrap
INSTALLED_BINS=(zsh ninja nvim fzf fd btop oh-my-posh stow l)
INSTALLED_DIRS=(share/nvim share/zsh share/zu lib/zsh)

# ─────────────────────────────────────────────────────────────────────────────
# Uninstall mode
# ─────────────────────────────────────────────────────────────────────────────

if (( UNINSTALL )); then
  info "Uninstalling programs..."

  # Remove from local prefix
  for bin in "${INSTALLED_BINS[@]}"; do
    if [[ -e "$LOCAL_PREFIX/bin/$bin" ]]; then
      rm -f "$LOCAL_PREFIX/bin/$bin"
      detail "Removed $LOCAL_PREFIX/bin/$bin"
    fi
  done
  for dir in "${INSTALLED_DIRS[@]}"; do
    if [[ -d "$LOCAL_PREFIX/$dir" ]]; then
      rm -rf "$LOCAL_PREFIX/$dir"
      detail "Removed $LOCAL_PREFIX/$dir"
    fi
  done

  # Remove from global prefix (requires sudo)
  NEED_SUDO=0
  for bin in "${INSTALLED_BINS[@]}"; do
    [[ -e "$GLOBAL_PREFIX/bin/$bin" ]] && NEED_SUDO=1
  done
  for dir in "${INSTALLED_DIRS[@]}"; do
    [[ -d "$GLOBAL_PREFIX/$dir" ]] && NEED_SUDO=1
  done

  if (( NEED_SUDO )); then
    info "Removing global installs (requires sudo)..."
    for bin in "${INSTALLED_BINS[@]}"; do
      if [[ -e "$GLOBAL_PREFIX/bin/$bin" ]]; then
        sudo rm -f "$GLOBAL_PREFIX/bin/$bin"
        detail "Removed $GLOBAL_PREFIX/bin/$bin"
      fi
    done
    for dir in "${INSTALLED_DIRS[@]}"; do
      if [[ -d "$GLOBAL_PREFIX/$dir" ]]; then
        sudo rm -rf "$GLOBAL_PREFIX/$dir"
        detail "Removed $GLOBAL_PREFIX/$dir"
      fi
    done
  fi

  # Remove zsh from /etc/shells if present
  if grep -qF "$GLOBAL_PREFIX/bin/zsh" /etc/shells 2>/dev/null; then
    sudo sed -i "\|$GLOBAL_PREFIX/bin/zsh|d" /etc/shells
    detail "Removed $GLOBAL_PREFIX/bin/zsh from /etc/shells"
  fi

  # Remove zsh exec line from .bashrc
  if [[ -f "$HOME/.bashrc" ]] && grep -qF '.local/bin/zsh' "$HOME/.bashrc"; then
    sed -i '\|.local/bin/zsh|d' "$HOME/.bashrc"
    detail "Removed zsh exec from ~/.bashrc"
  fi

  success "Uninstall complete"
  exit 0
fi

mkdir -p "$LOG_DIR"

# ─────────────────────────────────────────────────────────────────────────────
# Step 0: Initialize module system (for HPC environments)
# ─────────────────────────────────────────────────────────────────────────────

init_modules() {
  # Already initialized
  if type module &>/dev/null; then
    return 0
  fi

  # Try common module init locations
  local init_scripts=(
    "${MODULESHOME}/init/bash"
    "/usr/share/lmod/lmod/init/bash"
    "/usr/share/modules/init/bash"
    "/opt/modules/init/bash"
    "/etc/profile.d/modules.sh"
    "/etc/profile.d/lmod.sh"
  )

  for script in "${init_scripts[@]}"; do
    if [[ -f "$script" ]]; then
      source "$script" 2>/dev/null && return 0
    fi
  done
  return 1
}

# Try to load a module for a missing command
try_load_module() {
  local cmd="$1"
  shift
  local modules=("$@")

  # Skip if command exists or modules unavailable
  command -v "$cmd" &>/dev/null && return 0
  type module &>/dev/null || return 1

  for mod in "${modules[@]}"; do
    if module load "$mod" 2>/dev/null; then
      if command -v "$cmd" &>/dev/null; then
        detail "$cmd: loaded module '$mod'"
        return 0
      fi
      module unload "$mod" 2>/dev/null
    fi
  done
  return 1
}

if init_modules; then
  detail "Module system available"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Step 1: Check prerequisites (try modules for missing tools)
# ─────────────────────────────────────────────────────────────────────────────

info "Checking prerequisites..."

# Try to load modules for common build tools
try_load_module gcc    gcc gnu GCC gnu-compilers compiler/gnu
try_load_module make   gcc gnu GCC gnu-compilers compiler/gnu
try_load_module perl   perl Perl
try_load_module curl   curl Curl
try_load_module git    git Git
try_load_module tar    tar

MISSING=""
for cmd in git curl make perl tar; do
  if command -v "$cmd" &>/dev/null; then
    detail "$cmd: $(command -v "$cmd")"
  else
    MISSING="$MISSING $cmd"
  fi
done

if [[ -n "$MISSING" ]]; then
  error "Missing required tools:$MISSING"
  if type module &>/dev/null; then
    echo "Try: module avail | grep -iE '$(echo $MISSING | tr ' ' '|')'" >&2
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    echo "Install Xcode Command Line Tools: xcode-select --install" >&2
  elif command -v apt-get &>/dev/null; then
    echo "Install with: sudo apt-get install$MISSING" >&2
  elif command -v dnf &>/dev/null; then
    echo "Install with: sudo dnf install$MISSING" >&2
  fi
  exit 1
fi
success "All prerequisites found"

# ─────────────────────────────────────────────────────────────────────────────
# Step 2: Install stow (needed to symlink dotfiles)
# ─────────────────────────────────────────────────────────────────────────────

if command -v stow &>/dev/null; then
  info "stow already installed: $(command -v stow)"
elif [[ -x "$LOCAL_PREFIX/bin/stow" ]]; then
  info "stow already installed: $LOCAL_PREFIX/bin/stow"
  export PATH="$LOCAL_PREFIX/bin:$PATH"
else
  info "Installing stow..."
  detail "Log: $LOG_DIR/stow.log"
  export PREFIX="$LOCAL_PREFIX"
  if source "$DOTFILES_DIR/.config/install/stow" > "$LOG_DIR/stow.log" 2>&1; then
    export PATH="$LOCAL_PREFIX/bin:$PATH"
    success "stow installed to $LOCAL_PREFIX/bin/stow"
  else
    error "Failed to install stow (see $LOG_DIR/stow.log)"
    exit 1
  fi
fi

# ─────────────────────────────────────────────────────────────────────────────
# Step 3: Stow dotfiles
# ─────────────────────────────────────────────────────────────────────────────

info "Linking dotfiles..."
detail "Source: $DOTFILES_DIR"
detail "Target: $HOME"
cd "$DOTFILES_DIR"
if stow . -t ~ 2>"$LOG_DIR/stow-link.log"; then
  success "Dotfiles linked"
else
  error "Failed to link dotfiles (see $LOG_DIR/stow-link.log)"
  exit 1
fi

# ─────────────────────────────────────────────────────────────────────────────
# Step 4: Run shell setup (installs zsh if needed, then remaining tools)
# ─────────────────────────────────────────────────────────────────────────────

info "Running shell setup..."

# Determine install prefix for zsh
if (( GLOBAL_INSTALL )); then
  ZSH_PREFIX="$GLOBAL_PREFIX"
  INSTALL_ARGS="--global"
else
  ZSH_PREFIX="$LOCAL_PREFIX"
  INSTALL_ARGS=""
fi
(( FORCE_INSTALL )) && INSTALL_ARGS="$INSTALL_ARGS --force"

# Check if we need to install zsh (force mode ignores existing)
NEED_ZSH=0
if (( FORCE_INSTALL )); then
  NEED_ZSH=1
elif ! command -v zsh &>/dev/null; then
  NEED_ZSH=1
fi

if (( ! NEED_ZSH )); then
  detail "zsh: $(command -v zsh)"
  detail "Sourcing $HOME/.zprofile"
  zsh -c "source '$HOME/.zprofile' $INSTALL_ARGS"
else
  # Install zsh first, then run setup
  info "Installing zsh (not found in PATH)..."
  detail "Log: $LOG_DIR/zsh.log"
  export PREFIX="$ZSH_PREFIX"
  export LOCAL_PREFIX
  export GLOBAL_PREFIX
  export USE_SUDO=$GLOBAL_INSTALL
  export JOBS=$(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 1)
  if bash "$DOTFILES_DIR/.config/install/zsh" > "$LOG_DIR/zsh.log" 2>&1; then
    success "zsh installed to $ZSH_PREFIX/bin/zsh"
    export PATH="$ZSH_PREFIX/bin:$LOCAL_PREFIX/bin:$PATH"
    detail "Sourcing $HOME/.zprofile"
    "$ZSH_PREFIX/bin/zsh" -c "source '$HOME/.zprofile' $INSTALL_ARGS"
  else
    error "Failed to install zsh (see $LOG_DIR/zsh.log)"
    exit 1
  fi
fi

success "Bootstrap complete! Run 'exec zsh -l' to start your new shell."

# ─────────────────────────────────────────────────────────────────────────────
# Reminder for remote servers
# ─────────────────────────────────────────────────────────────────────────────

cat << 'EOF'

NOTE: If your default shell is bash but you want zsh for interactive sessions,
add this to the TOP of your ~/.bashrc to allow non-interactive commands (like
rpy, rsync, scp) to work without loading zsh:

    [[ $- != *i* ]] && return

This ensures 'exec zsh' only runs for interactive logins, not remote commands.
EOF
